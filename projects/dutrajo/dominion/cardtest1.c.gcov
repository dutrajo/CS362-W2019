        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <string.h>
        -:    5:#include <stdio.h>
        -:    6:#include <assert.h>
        -:    7:#include <stdlib.h>
        -:    8:#include <unistd.h>
        -:    9:#include <signal.h>
        -:   10:
        -:   11://set array size for output strings
        -:   12:#define MAX_STRING_SIZE 10000
        -:   13:
        -:   14://for handling crashes
        -:   15:volatile sig_atomic_t HAS_SIGSEGV = 0;
function sig_segv_handler called 0 returned 0% blocks executed 0%
    #####:   16:void sig_segv_handler(int sig_num)
        -:   17:{
    #####:   18:	HAS_SIGSEGV = 1;
    #####:   19:}
        -:   20:
        -:   21:/*
        -:   22:	void customPrintf(
        -:   23:						char* line,
        -:   24:						FILE* outputFile
        -:   25:						)
        -:   26:	Parameters:
        -:   27:		char* line: string to output,
        -:   28:		FILE* outputFile: file pointer to output file (can be null)
        -:   29:	Returns:
        -:   30:		Nothing
        -:   31:	Description:
        -:   32:		Will output a string (ends with '\0') to the console as well
        -:   33:		as to the output file if the pointer isn't null.
        -:   34:*/
function initializeString called 73 returned 100% blocks executed 100%
       73:   35:void initializeString(char *str, int size)
        -:   36:{
        -:   37:	//validate pointer isn't null
       73:   38:	if (str != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   39:	{
        -:   40:		//initialize array to all '\0' characters
       73:   41:		memset(str, '\0', sizeof(char) * size);
        -:   42:	}
       73:   43:}
        -:   44:
        -:   45:
        -:   46:/*
        -:   47:	void customPrintf(
        -:   48:						char* line,
        -:   49:						FILE* outputFile
        -:   50:						)
        -:   51:	Parameters:
        -:   52:		char* line: string to output,
        -:   53:		FILE* outputFile: file pointer to output file (can be null)
        -:   54:	Returns:
        -:   55:		Nothing
        -:   56:	Description:
        -:   57:		Will output a string (ends with '\0') to the console as well
        -:   58:		as to the output file if the pointer isn't null.
        -:   59:*/
function customPrintf called 70 returned 100% blocks executed 100%
       70:   60:void customPrintf(char* line, FILE* outputFile)
        -:   61:{
        -:   62:	//output the line to the console
       70:   63:	printf("%s", line);
call    0 returned 100%
        -:   64:
        -:   65:	//check if the file pointer is null
       70:   66:	if (outputFile != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   67:	{
        -:   68:		//not null, so output to file
       70:   69:		fprintf(outputFile, "%s", line);
call    0 returned 100%
        -:   70:	}
        -:   71:
        -:   72:	//re-initialize string 
       70:   73:	initializeString(line, MAX_STRING_SIZE);
call    0 returned 100%
       70:   74:}
        -:   75:
        -:   76:
        -:   77:/*
        -:   78:	int validateStewardCardEffect(
        -:   79:							int playerIndex,
        -:   80:							int indexHandCardPlayed,
        -:   81:							int handCardPlayed,
        -:   82:							int choice1,
        -:   83:							int choice2,
        -:   84:							int choice3,
        -:   85:							int *bonus,
        -:   86:							struct gameState *G,
        -:   87:							int detailedOutput,
        -:   88:							FILE* outputFile,
        -:   89:							int expectedPassOrFail
        -:   90:						)
        -:   91:	Parameters:
        -:   92:		int playerIndex: index of player who is playing card
        -:   93:		int indexHandCardPlayed: index of the played card in player's hand
        -:   94:		int handCardPlayed: value of the card that was played
        -:   95:		int choice1: selection choice 1=+2 cards, 2=+2 coins, 3=trash 2 cards
        -:   96:		int choice2: index of first card to trash from hand
        -:   97:		int choice3: index of second card to trash from hand
        -:   98:		int *bonus: bonus coins pointer
        -:   99:		struct gameState *G: pointer to gameState object
        -:  100:		int detailedOutput: 1 = output status, anything else don't
        -:  101:		FILE* outputFile: pointer to output file (can be null)
        -:  102:		int expectedPassOrFail: value indicating expected function return value
        -:  103:	Returns:
        -:  104:		int 0 = failure, 1 = success
        -:  105:	Description:
        -:  106:		Will test the cardEffect for 'steward' card. Returns 0 if test
        -:  107:		fails, 1 if test is successful.
        -:  108:*/
function validateStewardCardEffect called 3 returned 100% blocks executed 76%
        3:  109:int validateStewardCardEffect(
        -:  110:	int playerIndex,
        -:  111:	int indexHandCardPlayed,
        -:  112:	int handCardPlayed,
        -:  113:	int choice1, // 1 = +2 cards to hand, 2 = +2 coins, anything else = trash two cards
        -:  114:	int choice2, // index of card to discard
        -:  115:	int choice3, // index of card to discard
        -:  116:	int *bonus,
        -:  117:	struct gameState *G,
        -:  118:	int detailedOutput,//0 = no output, 1 = output
        -:  119:	FILE* outputFile,
        -:  120:	int expectedPassOrFail 
        -:  121:)
        -:  122:{
        -:  123:	//create gamestate for testing
        -:  124:	struct gameState tempG;
        -:  125:
        -:  126:	//first copy gameState to test object
        3:  127:	memcpy(&tempG, G, sizeof(struct gameState));
        -:  128:
        -:  129:	//assume we're gonna pass check
        3:  130:	int passesCheck = 1;
        -:  131:
        -:  132:	//assume we're going to pass overall tests
        3:  133:	int overallTestPass = 1;
        -:  134:
        -:  135:	//output string for print statements
        3:  136:	char *str = malloc(sizeof(char) * MAX_STRING_SIZE);
        -:  137:
        -:  138:	//initialize output string
        3:  139:	initializeString(str, MAX_STRING_SIZE);
call    0 returned 100%
        -:  140:
        -:  141:	//execute the card effect
        3:  142:	sprintf(str, "\tRunning cardEffect For Steward....");
        3:  143:	if(detailedOutput) customPrintf(str, outputFile);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  144:
        -:  145:	//reset check
        3:  146:	passesCheck = 1;
        -:  147:
        -:  148:	//run the function
        3:  149:	int res = cardEffect(handCardPlayed, choice1, choice2, choice3, &tempG, indexHandCardPlayed, bonus);
call    0 returned 100%
        -:  150:
        3:  151:	if (res != expectedPassOrFail)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  152:	{
    #####:  153:		passesCheck = overallTestPass = 0;
        -:  154:	}
        -:  155:
        -:  156:	//output results to screen and file
        3:  157:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  158:	{
        3:  159:		if (passesCheck)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  160:		{
        3:  161:			sprintf(str, "Expected %d, function returned %d. Passed.\n", expectedPassOrFail, res);
        3:  162:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  163:		}
        -:  164:		else
        -:  165:		{
    #####:  166:			sprintf(str, "Expected %d, function returned %d. Failed!!!\n", expectedPassOrFail, res);
    #####:  167:			customPrintf(str, outputFile);
call    0 never executed
        -:  168:		}
        -:  169:	}
        -:  170:
        -:  171:	//reset check
        3:  172:	passesCheck = 1;
        -:  173:
        -:  174:	//for loop variables
        3:  175:	int i = 0;
        3:  176:	int j = 0;
        -:  177:
        -:  178:	//output status to screen and file
        3:  179:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  180:	{
        3:  181:		sprintf(str, "\tDetermining Users Selected Action....");
        3:  182:		customPrintf(str, outputFile);
call    0 returned 100%
        -:  183:	}
        -:  184:
        -:  185:	//now validate card effect executed as expected
        3:  186:	if (choice1 == 1)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  187:	{
        -:  188:		//output status to screen and file
        1:  189:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  190:		{
        1:  191:			sprintf(str, "gain two cards.\n");
        1:  192:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  193:		}
        -:  194:
        -:  195:		//reset check
        1:  196:		passesCheck = 1;
        -:  197:
        -:  198:		//output status to screen and file
        1:  199:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  200:		{
        1:  201:			sprintf(str, "\tChecking if handCount increased correctly...");
        1:  202:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  203:		}
        -:  204:
        -:  205:		//check if player specified hand increased by one card
        -:  206:		//because original played card was put into discard pile (so +2 - 1 = 1)
        1:  207:		if (tempG.handCount[playerIndex] != G->handCount[playerIndex] + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  208:		{
    #####:  209:			passesCheck = overallTestPass = 0;
        -:  210:		}
        -:  211:
        -:  212:		//output status to screen and file
        1:  213:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  214:		{
        1:  215:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  216:			{
        1:  217:				sprintf(str, "Passed.\n");
        1:  218:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  219:			}
        -:  220:			else
        -:  221:			{
    #####:  222:				sprintf(str, "Failed!!!!!\n");
    #####:  223:				customPrintf(str, outputFile);
call    0 never executed
        -:  224:			}
        -:  225:		}
        -:  226:
        -:  227:		//reset check
        1:  228:		passesCheck = 1;
        -:  229:
        -:  230:		//output status to screen and file
        1:  231:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  232:		{
        1:  233:			sprintf(str, "\tVerifying cards received are valid cards...");
        1:  234:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  235:		}
        -:  236:
        -:  237:		//verify the two new cards in player's hand are valid cards
        3:  238:		for (i = G->handCount[playerIndex] - 1; i < tempG.handCount[playerIndex]; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  239:		{
        -:  240:			//check if card is within enum range
        2:  241:			if (tempG.hand[playerIndex][i] < curse || tempG.hand[playerIndex][i] > treasure_map)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:  242:			{
    #####:  243:				passesCheck = overallTestPass = 0;
    #####:  244:				break;
        -:  245:			}
        -:  246:		}
        -:  247:
        -:  248:		//output status to screen and file
        1:  249:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  250:		{
        1:  251:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  252:			{
        1:  253:				sprintf(str, "Passed.\n");
        1:  254:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  255:			}
        -:  256:			else
        -:  257:			{
    #####:  258:				sprintf(str, "Failed!!!!!\n");
    #####:  259:				customPrintf(str, outputFile);
call    0 never executed
        -:  260:			}
        -:  261:		}
        -:  262:
        -:  263:		//reset check pass
        1:  264:		passesCheck = 1;
        -:  265:
        -:  266:		//output status to screen and file
        1:  267:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  268:		{
        1:  269:			sprintf(str, "\tVerifying first card came from player's deck...");
        1:  270:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  271:		}
        -:  272:
        -:  273:		//check that the first of two drawn cards came from the player's deck
        1:  274:		if (tempG.hand[playerIndex][tempG.handCount[playerIndex] - 2] != G->deck[playerIndex][G->deckCount[playerIndex] - 1])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  275:		{
        -:  276:			//didn't come from player's deck
    #####:  277:			passesCheck = overallTestPass = 0;
        -:  278:		}
        -:  279:
        -:  280:		//output status to screen and file
        1:  281:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  282:		{
        1:  283:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  284:			{
        1:  285:				sprintf(str, "Passed.\n");
        1:  286:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  287:			}
        -:  288:			else
        -:  289:			{
    #####:  290:				sprintf(str, "Failed!!!!!\n");
    #####:  291:				customPrintf(str, outputFile);
call    0 never executed
        -:  292:			}
        -:  293:		}
        -:  294:
        -:  295:		//reset check
        1:  296:		passesCheck = 1;
        -:  297:
        -:  298:		//output status to screen and file
        1:  299:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  300:		{
        1:  301:			sprintf(str, "\tVerifying second card came from player's deck...");
        1:  302:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  303:		}
        -:  304:
        -:  305:		//check that the second of two drawn cards came from the player's deck
        1:  306:		if (tempG.hand[playerIndex][tempG.handCount[playerIndex] - 1] != G->deck[playerIndex][G->deckCount[playerIndex] - 2])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  307:		{
        -:  308:			//didn't come from player's deck
    #####:  309:			passesCheck = overallTestPass = 0;
        -:  310:		}
        -:  311:
        -:  312:		//output status to screen and file
        1:  313:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  314:		{
        1:  315:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  316:			{
        1:  317:				sprintf(str, "Passed.\n");
        1:  318:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  319:			}
        -:  320:			else
        -:  321:			{
    #####:  322:				sprintf(str, "Failed!!!!!\n");
    #####:  323:				customPrintf(str, outputFile);
call    0 never executed
        -:  324:			}
        -:  325:		}
        -:  326:
        -:  327:		//reset check
        1:  328:		passesCheck = 1;
        -:  329:
        -:  330:		//output status to screen and file
        1:  331:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  332:		{
        1:  333:			sprintf(str, "\tChecking player's coins didn't change...");
        1:  334:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  335:		}
        -:  336:
        -:  337:		//now validate that player's coins didn't change
        1:  338:		if (tempG.coins != G->coins)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  339:		{
        -:  340:			//coins were modified whent they shouldn't have
    #####:  341:			passesCheck = overallTestPass = 0;
        -:  342:		}
        -:  343:
        -:  344:		//output status to screen and file
        1:  345:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  346:		{
        1:  347:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  348:			{
        1:  349:				sprintf(str, "Passed.\n");
        1:  350:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  351:			}
        -:  352:			else
        -:  353:			{
    #####:  354:				sprintf(str, "Failed!!!!!\n");
    #####:  355:				customPrintf(str, outputFile);
call    0 never executed
        -:  356:			}
        -:  357:		}
        -:  358:
        -:  359:		//reset check
        1:  360:		passesCheck = 1;
        -:  361:
        -:  362:		//output status to screen and file
        1:  363:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  364:		{
        1:  365:			sprintf(str, "\tChecking played card was removed from player's hand...");
        1:  366:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  367:		}
        -:  368:
        -:  369:		//validate that we discarded correct played card from hand
        1:  370:		int *newHandCardsCount = malloc(sizeof(int) * (treasure_map + 1));
        1:  371:		int *originalHandCardsCount = malloc(sizeof(int) * (treasure_map + 1));
       28:  372:		for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  373:		{
       27:  374:			newHandCardsCount[i] = originalHandCardsCount[i] = 0;
        -:  375:		}
        -:  376:
        -:  377:		//iterate through new hand and increment card counts
        7:  378:		for (i = 0; i < tempG.handCount[playerIndex]; i++)
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -:  379:		{
        6:  380:			newHandCardsCount[tempG.hand[playerIndex][i]]++;
        -:  381:		}
        -:  382:
        -:  383:		//iterate through old hand and increment card counts
        6:  384:		for (i = 0; i < G->handCount[playerIndex]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  385:		{
        5:  386:			originalHandCardsCount[G->hand[playerIndex][i]]++;
        -:  387:		}
        -:  388:
        -:  389:		//verify that card removed from hand was the correct card
        1:  390:		if (newHandCardsCount[handCardPlayed] != originalHandCardsCount[handCardPlayed] - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  391:		{
    #####:  392:			passesCheck = overallTestPass = 0;
        -:  393:		}
        -:  394:
        -:  395:		//output status to screen and file
        1:  396:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  397:		{
        1:  398:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  399:			{
        1:  400:				sprintf(str, "Passed.\n");
        1:  401:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  402:			}
        -:  403:			else
        -:  404:			{
    #####:  405:				sprintf(str, "Failed!!!!!\n");
    #####:  406:				customPrintf(str, outputFile);
call    0 never executed
        -:  407:			}
        -:  408:		}
        -:  409:
        -:  410:		//reset check
        1:  411:		passesCheck = 1;
        -:  412:
        -:  413:		//output status to screen and file
        1:  414:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  415:		{
        1:  416:			sprintf(str, "\tChecking original cards in hand didn't change (except played card missing)...");
        1:  417:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  418:		}
        -:  419:
        -:  420:		//perform check
       28:  421:		for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  422:		{
        -:  423:			//if we're on the cards that got added
       53:  424:			if (i == tempG.hand[playerIndex][tempG.handCount[playerIndex] - 2] ||
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
       26:  425:				i == tempG.hand[playerIndex][tempG.handCount[playerIndex] - 1] 
        -:  426:				)
        -:  427:			{
        3:  428:				if (tempG.hand[playerIndex][tempG.handCount[playerIndex] - 2] ==
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        1:  429:					tempG.hand[playerIndex][tempG.handCount[playerIndex] - 1])
        -:  430:				{
        1:  431:					if (newHandCardsCount[i] != originalHandCardsCount[i] + 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  432:					{
        -:  433:						//didn't find expected count
    #####:  434:						passesCheck = overallTestPass = 0;
        -:  435:					}
        -:  436:				}
        -:  437:				else
        -:  438:				{
    #####:  439:					if (newHandCardsCount[i] != originalHandCardsCount[i] + 1)
branch  0 never executed
branch  1 never executed
        -:  440:					{
        -:  441:						//didn't find expected count
    #####:  442:						passesCheck = overallTestPass = 0;
        -:  443:					}
        -:  444:				}
        -:  445:				
        -:  446:			}
        -:  447:			//check if we're on the card that was played
       26:  448:			else if (i == handCardPlayed)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  449:			{
        1:  450:				if (newHandCardsCount[i] != originalHandCardsCount[i] - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  451:				{
    #####:  452:					passesCheck = overallTestPass = 0;
        -:  453:				}
        -:  454:			}
        -:  455:			else
        -:  456:			{
       25:  457:				if (newHandCardsCount[i] != originalHandCardsCount[i])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  458:				{
    #####:  459:					passesCheck = overallTestPass = 0;
        -:  460:				}
        -:  461:			}
        -:  462:		}
        -:  463:
        -:  464:		//output status to screen and file
        1:  465:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  466:		{
        1:  467:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  468:			{
        1:  469:				sprintf(str, "Passed.\n");
        1:  470:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  471:			}
        -:  472:			else
        -:  473:			{
    #####:  474:				sprintf(str, "Failed!!!!!\n");
    #####:  475:				customPrintf(str, outputFile);
call    0 never executed
        -:  476:			}
        -:  477:		}
        -:  478:
        -:  479:		//free dynamic memory
        1:  480:		free(newHandCardsCount);
        1:  481:		free(originalHandCardsCount);
        -:  482:
        -:  483:	}
        2:  484:	else if (choice1 == 2)
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        -:  485:	{
        -:  486:		// output status to screen and file
        1:  487:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  488:		{
        1:  489:			sprintf(str, "gain two coins.\n");
        1:  490:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  491:		}
        -:  492:
        -:  493:		//reset check
        1:  494:		passesCheck = 1;
        -:  495:
        -:  496:		//output status to screen and file
        1:  497:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  498:		{
        1:  499:			sprintf(str, "\tChecking player gained two coins...");
        1:  500:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  501:		}
        -:  502:
        -:  503:		//check if player state has increased coin count +2
        1:  504:		if (tempG.coins != G->coins + 2)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  505:		{
    #####:  506:			passesCheck = overallTestPass = 0;
        -:  507:		}
        -:  508:
        -:  509:		//output status to screen and file
        1:  510:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  511:		{
        1:  512:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  513:			{
        1:  514:				sprintf(str, "Passed.\n");
        1:  515:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  516:			}
        -:  517:			else
        -:  518:			{
    #####:  519:				sprintf(str, "Failed!!!!!\n");
    #####:  520:				customPrintf(str, outputFile);
call    0 never executed
        -:  521:			}
        -:  522:		}
        -:  523:
        -:  524:		//reset check
        1:  525:		passesCheck = 1;
        -:  526:
        -:  527:		//output status to screen and file
        1:  528:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  529:		{
        1:  530:			sprintf(str, "\tChecking played card was removed from player's hand...");
        1:  531:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  532:		}
        -:  533:
        -:  534:		//validate that we discarded correct played card from hand
        1:  535:		int *newHandCardsCount = malloc(sizeof(int) * (treasure_map + 1));
        1:  536:		int *originalHandCardsCount = malloc(sizeof(int) * (treasure_map + 1));
       28:  537:		for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  538:		{
       27:  539:			newHandCardsCount[i] = originalHandCardsCount[i] = 0;
        -:  540:		}
        -:  541:
        -:  542:		//iterate through new hand and increment card counts
        5:  543:		for (i = 0; i < tempG.handCount[playerIndex]; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  544:		{
        4:  545:			newHandCardsCount[tempG.hand[playerIndex][i]]++;
        -:  546:		}
        -:  547:
        -:  548:		//iterate through old hand and increment card counts
        6:  549:		for (i = 0; i < G->handCount[playerIndex]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  550:		{
        5:  551:			originalHandCardsCount[G->hand[playerIndex][i]]++;
        -:  552:		}
        -:  553:
        -:  554:		//verify that card removed from hand was the correct card
        1:  555:		if (newHandCardsCount[handCardPlayed] != originalHandCardsCount[handCardPlayed] - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  556:		{
    #####:  557:			passesCheck = overallTestPass = 0;
        -:  558:		}
        -:  559:
        -:  560:		//output status to screen and file
        1:  561:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  562:		{
        1:  563:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  564:			{
        1:  565:				sprintf(str, "Passed.\n");
        1:  566:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  567:			}
        -:  568:			else
        -:  569:			{
    #####:  570:				sprintf(str, "Failed!!!!!\n");
    #####:  571:				customPrintf(str, outputFile);
call    0 never executed
        -:  572:			}
        -:  573:		}
        -:  574:
        -:  575:		//reset check
        1:  576:		passesCheck = 1;
        -:  577:
        -:  578:		//output status to screen and file
        1:  579:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  580:		{
        1:  581:			sprintf(str, "\tChecking original cards in hand didn't change (except played card missing)...");
        1:  582:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  583:		}
        -:  584:
        -:  585:		//perform check
       28:  586:		for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  587:		{
        -:  588:			
        -:  589:			//check if we're on the card that was played
       27:  590:			if (i == handCardPlayed)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  591:			{
        1:  592:				if (newHandCardsCount[i] != originalHandCardsCount[i] - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  593:				{
    #####:  594:					passesCheck = overallTestPass = 0;
        -:  595:				}
        -:  596:			}
        -:  597:			else
        -:  598:			{
       26:  599:				if (newHandCardsCount[i] != originalHandCardsCount[i])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  600:				{
    #####:  601:					passesCheck = overallTestPass = 0;
        -:  602:				}
        -:  603:			}
        -:  604:		}
        -:  605:
        -:  606:		//output status to screen and file
        1:  607:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  608:		{
        1:  609:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  610:			{
        1:  611:				sprintf(str, "Passed.\n");
        1:  612:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  613:			}
        -:  614:			else
        -:  615:			{
    #####:  616:				sprintf(str, "Failed!!!!!\n");
    #####:  617:				customPrintf(str, outputFile);
call    0 never executed
        -:  618:			}
        -:  619:		}
        -:  620:
        1:  621:		free(newHandCardsCount);
        1:  622:		free(originalHandCardsCount);
        -:  623:	}
        -:  624:	else
        -:  625:	{
        -:  626:		//output status to screen and file
        1:  627:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  628:		{
        1:  629:			sprintf(str, "trash two cards.\n");
        1:  630:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  631:		}
        -:  632:
        -:  633:		//reset check
        1:  634:		passesCheck = 1;
        -:  635:
        -:  636:		//output status to screen and file
        1:  637:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  638:		{
        1:  639:			sprintf(str, "\tChecking correct count of cards missing from player's hand...");
        1:  640:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  641:		}
        -:  642:
        1:  643:		if (tempG.handCount[playerIndex] != G->handCount[playerIndex] - 3)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  644:		{
    #####:  645:			passesCheck = overallTestPass = 0;
        -:  646:		}
        -:  647:
        -:  648:		//output status to screen and file
        1:  649:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  650:		{
        1:  651:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  652:			{
        1:  653:				sprintf(str, "Passed.\n");
        1:  654:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  655:			}
        -:  656:			else
        -:  657:			{
    #####:  658:				sprintf(str, "Failed!!!!!\n");
    #####:  659:				customPrintf(str, outputFile);
call    0 never executed
        -:  660:			}
        -:  661:		}
        -:  662:
        -:  663:		//reset check
        1:  664:		passesCheck = 1;
        -:  665:
        -:  666:		//output status to screen and file
        1:  667:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  668:		{
        1:  669:			sprintf(str, "\tChecking correct card values are missing from player's hand...");
        1:  670:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  671:		}
        -:  672:
        -:  673:		//we've removed three cards (2 trash + 1 played), verify the correct cards are out of player's hand
        1:  674:		int *newHandCardsCount = malloc(sizeof(int) * (treasure_map + 1));
        1:  675:		int *originalHandCardsCount = malloc(sizeof(int) * (treasure_map + 1));
       28:  676:		for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  677:		{
       27:  678:			newHandCardsCount[i] = originalHandCardsCount[i] = 0;
        -:  679:		}
        -:  680:
        -:  681:		//iterate through new hand and increment card counts
        3:  682:		for (i = 0; i < tempG.handCount[playerIndex]; i++)
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        -:  683:		{
        2:  684:			newHandCardsCount[tempG.hand[playerIndex][i]]++;
        -:  685:		}
        -:  686:
        -:  687:		//iterate through old hand and increment card counts
        6:  688:		for (i = 0; i < G->handCount[playerIndex]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -:  689:		{
        5:  690:			originalHandCardsCount[G->hand[playerIndex][i]]++;
        -:  691:		}
        -:  692:
        -:  693:		//determine card values that were to be trashed
        1:  694:		int card1ValueToTrash = G->hand[playerIndex][choice2];
        1:  695:		int card2ValueToTrash = G->hand[playerIndex][choice3];
        -:  696:
        -:  697:		//check if card amounts were reduced by 1 for each card type selected (or 2 if same type card)
        1:  698:		if (card1ValueToTrash == card2ValueToTrash)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  699:		{
    #####:  700:			if (originalHandCardsCount[card1ValueToTrash] != newHandCardsCount[card1ValueToTrash] + 2)
branch  0 never executed
branch  1 never executed
        -:  701:			{
        -:  702:				//first card selected wasn't removed from hand correctly
    #####:  703:				passesCheck = overallTestPass = 0;
        -:  704:
        -:  705:			}
        -:  706:		}
        -:  707:		else
        -:  708:		{
        1:  709:			if (originalHandCardsCount[card1ValueToTrash] != newHandCardsCount[card1ValueToTrash] + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  710:			{
        -:  711:				//first card selected wasn't removed from hand correctly
    #####:  712:				passesCheck = overallTestPass = 0;
        -:  713:
        -:  714:			}
        -:  715:		}
        -:  716:
        -:  717:		//check if second card amounts were changed correctly
        1:  718:		if (originalHandCardsCount[card2ValueToTrash] != newHandCardsCount[card2ValueToTrash] + 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  719:		{
        -:  720:			//second card selected wasn't removed from hand correctly
    #####:  721:			passesCheck = overallTestPass = 0;
        -:  722:		}
        -:  723:		
        -:  724:		//check that original played card amounts were changed correctly
        1:  725:		if (newHandCardsCount[handCardPlayed] != originalHandCardsCount[handCardPlayed] - 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  726:		{
        1:  727:			passesCheck = overallTestPass = 0;
        -:  728:		}
        -:  729:
        -:  730:		//output status to screen and file
        1:  731:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  732:		{
        1:  733:			if (passesCheck == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  734:			{
    #####:  735:				sprintf(str, "Passed.\n");
    #####:  736:				customPrintf(str, outputFile);
call    0 never executed
        -:  737:			}
        -:  738:			else
        -:  739:			{
        1:  740:				sprintf(str, "Failed!!!!!\n");
        1:  741:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  742:			}
        -:  743:		}
        -:  744:
        -:  745:		//reset check
        1:  746:		passesCheck = 1;
        -:  747:
        -:  748:		//output status to screen and file
        1:  749:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  750:		{
        1:  751:			sprintf(str, "\tChecking cards in hand didn't change (except played card, and trashed missing)...");
        1:  752:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  753:		}
        -:  754:
        -:  755:		//perform check
       28:  756:		for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  757:		{
        -:  758:
        -:  759:			//check if we're on the card that was played
       27:  760:			if (i == handCardPlayed)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  761:			{
        1:  762:				if (newHandCardsCount[i] != originalHandCardsCount[i] - 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  763:				{
        1:  764:					passesCheck = overallTestPass = 0;
        -:  765:				}
        -:  766:			}
       26:  767:			else if (i == G->hand[playerIndex][choice2] || i == G->hand[playerIndex][choice3])
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
branch  2 taken 4% (fallthrough)
branch  3 taken 96%
        -:  768:			{
        4:  769:				if (card1ValueToTrash == card2ValueToTrash)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  770:				{
    #####:  771:					if (newHandCardsCount[i] != originalHandCardsCount[i] - 2)
branch  0 never executed
branch  1 never executed
        -:  772:					{
    #####:  773:						passesCheck = overallTestPass = 0;
        -:  774:					}
        -:  775:				}
        -:  776:				else
        -:  777:				{
        2:  778:					if (newHandCardsCount[i] != originalHandCardsCount[i] - 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  779:					{
    #####:  780:						passesCheck = overallTestPass = 0;
        -:  781:					}
        -:  782:				}
        -:  783:			}
        -:  784:			else
        -:  785:			{
       24:  786:				if (newHandCardsCount[i] != originalHandCardsCount[i])
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
        -:  787:				{
        1:  788:					passesCheck = overallTestPass = 0;
        -:  789:				}
        -:  790:			}
        -:  791:		}
        -:  792:
        -:  793:		//output status to screen and file
        1:  794:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  795:		{
        1:  796:			if (passesCheck == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  797:			{
    #####:  798:				sprintf(str, "Passed.\n");
    #####:  799:				customPrintf(str, outputFile);
call    0 never executed
        -:  800:			}
        -:  801:			else
        -:  802:			{
        1:  803:				sprintf(str, "Failed!!!!!\n");
        1:  804:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  805:			}
        -:  806:		}
        -:  807:
        1:  808:		free(newHandCardsCount);
        1:  809:		free(originalHandCardsCount);
        -:  810:
        -:  811:		//reset check
        1:  812:		passesCheck = 1;
        -:  813:
        -:  814:		//output status to screen and file
        1:  815:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  816:		{
        1:  817:			sprintf(str, "\tChecking trashed cards didn't end up in discard deck...");
        1:  818:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  819:		}
        -:  820:
        1:  821:		int *newDiscardDeckCounts = malloc(sizeof(int) * (treasure_map + 1));
        1:  822:		int *oldDiscardDeckCounts = malloc(sizeof(int) * (treasure_map + 1));
       28:  823:		for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  824:		{
       27:  825:			newDiscardDeckCounts[i] = oldDiscardDeckCounts[i] = 0;
        -:  826:		}
        -:  827:
        -:  828:		//iterate through discard and increment card counts
        1:  829:		for (i = 0; i < tempG.discardCount[playerIndex]; i++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  830:		{
    #####:  831:			if(tempG.discard[playerIndex][i] >= 0 && tempG.discard[playerIndex][i] < treasure_map + 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  832:				newDiscardDeckCounts[tempG.discard[playerIndex][i]]++;
        -:  833:		}
        -:  834:
        -:  835:		//iterate through discard and increment card counts
        1:  836:		for (i = 0; i < G->discardCount[playerIndex]; i++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  837:		{
    #####:  838:			if (G->discard[playerIndex][i] >= 0 && G->discard[playerIndex][i] < treasure_map + 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  839:				oldDiscardDeckCounts[G->discard[playerIndex][i]]++;
        -:  840:		}
        -:  841:
        -:  842:		//check if trashed cards are in discard pile
        2:  843:		if (newDiscardDeckCounts[card1ValueToTrash] != oldDiscardDeckCounts[card1ValueToTrash] ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        1:  844:			newDiscardDeckCounts[card2ValueToTrash] != oldDiscardDeckCounts[card2ValueToTrash])
        -:  845:		{
    #####:  846:			passesCheck = overallTestPass = 0;
        -:  847:		}
        -:  848:
        -:  849:		//output status to screen and file
        1:  850:		if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  851:		{
        1:  852:			if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  853:			{
        1:  854:				sprintf(str, "Passed.\n");
        1:  855:				customPrintf(str, outputFile);
call    0 returned 100%
        -:  856:			}
        -:  857:			else
        -:  858:			{
    #####:  859:				sprintf(str, "Failed!!!!!\n");
    #####:  860:				customPrintf(str, outputFile);
call    0 never executed
        -:  861:			}
        -:  862:		}
        -:  863:
        -:  864:		//free dynamic memory
        1:  865:		free(newDiscardDeckCounts);
        1:  866:		free(oldDiscardDeckCounts);
        -:  867:		
        -:  868:	}
        -:  869:
        -:  870:	//output status to screen and file
        3:  871:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  872:	{
        3:  873:		sprintf(str, "\tChecking played card ended up in discard pile...");
        3:  874:		customPrintf(str, outputFile);
call    0 returned 100%
        -:  875:	}
        -:  876:
        3:  877:	int *newDiscardDeckCounts = malloc(sizeof(int) * (treasure_map + 1));
        3:  878:	int *oldDiscardDeckCounts = malloc(sizeof(int) * (treasure_map + 1));
       84:  879:	for (i = 0; i < treasure_map + 1; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  880:	{
       81:  881:		newDiscardDeckCounts[i] = oldDiscardDeckCounts[i] = 0;
        -:  882:	}
        -:  883:
        -:  884:	//iterate through discard and increment card counts
        3:  885:	for (i = 0; i < tempG.discardCount[playerIndex]; i++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  886:	{
    #####:  887:		if (tempG.discard[playerIndex][i] >= 0 && tempG.discard[playerIndex][i] < treasure_map + 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  888:			newDiscardDeckCounts[tempG.discard[playerIndex][i]]++;
        -:  889:	}
        -:  890:
        -:  891:	//iterate through discard and increment card counts
        3:  892:	for (i = 0; i < G->discardCount[playerIndex]; i++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  893:	{
    #####:  894:		if (G->discard[playerIndex][i] >= 0 && G->discard[playerIndex][i] < treasure_map + 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  895:			oldDiscardDeckCounts[G->discard[playerIndex][i]]++;
        -:  896:	}
        -:  897:
        -:  898:	//check if trashed cards are in discard pile
        3:  899:	if (newDiscardDeckCounts[handCardPlayed] != oldDiscardDeckCounts[handCardPlayed] + 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  900:	{
        3:  901:		passesCheck = overallTestPass = 0;
        -:  902:	}
        -:  903:
        -:  904:	//output status to screen and file
        3:  905:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  906:	{
        3:  907:		if (passesCheck == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  908:		{
    #####:  909:			sprintf(str, "Passed.\n");
    #####:  910:			customPrintf(str, outputFile);
call    0 never executed
        -:  911:		}
        -:  912:		else
        -:  913:		{
        3:  914:			sprintf(str, "Failed!!!!!\n");
        3:  915:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  916:		}
        -:  917:	}
        -:  918:
        -:  919:	//free dynamic memory
        3:  920:	free(newDiscardDeckCounts);
        3:  921:	free(oldDiscardDeckCounts);
        -:  922:
        -:  923:
        -:  924:	//initially assume we'll pass the check
        3:  925:	passesCheck = 1;
        -:  926:
        -:  927:	//output status to screen and file
        3:  928:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  929:	{
        3:  930:		sprintf(str, "\tChecking other player's hands, decks, and discards weren't changed...");
        3:  931:		customPrintf(str, outputFile);
call    0 returned 100%
        -:  932:	}
        -:  933:
        -:  934:	//verify all other player's hands, decks, discard piles are identical to original values before function execution
       15:  935:	for (i = 0; i < tempG.numPlayers; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  936:	{
        -:  937:		//jump out of loop if something fails
       12:  938:		if (!passesCheck) break;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  939:
        -:  940:		//skip checks for playerIndex, we'll check those decks seperately
       12:  941:		if (i != playerIndex)
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
        -:  942:		{
        -:  943:			//make sure hand counts are the same
        9:  944:			if (tempG.handCount[i] == G->handCount[i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  945:			{
        -:  946:				//check player's hand for changes
        9:  947:				for (j = 0; j < tempG.handCount[i]; j++)
branch  0 taken 0%
branch  1 taken 100% (fallthrough)
        -:  948:				{
        -:  949:					//if the hand cards aren't the same
    #####:  950:					if (tempG.hand[i][j] != G->hand[i][j])
branch  0 never executed
branch  1 never executed
        -:  951:					{
        -:  952:						//fails check...
    #####:  953:						passesCheck = overallTestPass = 0;
    #####:  954:						break;
        -:  955:					}
        -:  956:				}
        -:  957:			}
        -:  958:			else
        -:  959:			{
        -:  960:				//original hand and new hand aren't the same count
    #####:  961:				passesCheck = overallTestPass = 0;
    #####:  962:				break;
        -:  963:			}
        -:  964:
        -:  965:			//make sure deck counts are the same
        9:  966:			if (tempG.deckCount[i] == G->deckCount[i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  967:			{
        -:  968:				//iterate through cards and make sure identical
       99:  969:				for (j = 0; j < tempG.deckCount[i]; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  970:				{
        -:  971:					//check if cards are the same
       90:  972:					if (tempG.deck[i][j] != G->deck[i][j])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  973:					{
        -:  974:						//fails check...
    #####:  975:						passesCheck = overallTestPass = 0;
    #####:  976:						break;
        -:  977:					}
        -:  978:				}
        -:  979:			}
        -:  980:			else
        -:  981:			{
        -:  982:				//original deck count doesn't match new deck count
    #####:  983:				passesCheck = 0;
    #####:  984:				break;
        -:  985:			}
        -:  986:
        -:  987:			//check discard piles are the same
        9:  988:			if (tempG.discardCount[i] == G->discardCount[i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  989:			{
        -:  990:				//iterate through discard piles and check for identical
        9:  991:				if (tempG.discard[i][j] != G->discard[i][j])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  992:				{
        -:  993:					//fails check....
    #####:  994:					passesCheck = overallTestPass = 0;
    #####:  995:					break;
        -:  996:				}
        -:  997:			}
        -:  998:			else
        -:  999:			{
        -: 1000:				//original discard pile doesn't match new one
    #####: 1001:				passesCheck = overallTestPass = 0;
    #####: 1002:				break;
        -: 1003:			}
        -: 1004:		}
        -: 1005:	}
        -: 1006:
        -: 1007:	//output status to screen and file
        3: 1008:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1009:	{
        3: 1010:		if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1011:		{
        3: 1012:			sprintf(str, "Passed.\n");
        3: 1013:			customPrintf(str, outputFile);
call    0 returned 100%
        -: 1014:		}
        -: 1015:		else
        -: 1016:		{
    #####: 1017:			sprintf(str, "Failed!!!!!\n");
    #####: 1018:			customPrintf(str, outputFile);
call    0 never executed
        -: 1019:		}
        -: 1020:	}
        -: 1021:
        -: 1022:	//reset check
        3: 1023:	passesCheck = 1;
        -: 1024:
        -: 1025:	//output status to screen and file
        3: 1026:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1027:	{
        3: 1028:		sprintf(str, "\tChecking current player's turn hasn't changed...");
        3: 1029:		customPrintf(str, outputFile);
call    0 returned 100%
        -: 1030:	}
        -: 1031:
        -: 1032:	//also check that player's turn hasn't changed 
        3: 1033:	if (tempG.whoseTurn != G->whoseTurn)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1034:	{
        -: 1035:		//function modified turn inside card effect (shouldn't happen)
    #####: 1036:		passesCheck = overallTestPass = 0;
        -: 1037:	}
        -: 1038:
        -: 1039:	//output status to screen and file
        3: 1040:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1041:	{
        3: 1042:		if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1043:		{
        3: 1044:			sprintf(str, "Passed.\n");
        3: 1045:			customPrintf(str, outputFile);
call    0 returned 100%
        -: 1046:		}
        -: 1047:		else
        -: 1048:		{
    #####: 1049:			sprintf(str, "Failed!!!!!\n");
    #####: 1050:			customPrintf(str, outputFile);
call    0 never executed
        -: 1051:		}
        -: 1052:	}
        -: 1053:
        -: 1054:	//reset check
        3: 1055:	passesCheck = 1;
        -: 1056:
        -: 1057:	//output status to screen and file
        3: 1058:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1059:	{
        3: 1060:		sprintf(str, "\tChecking player's coins weren't modified incorrectly..");
        3: 1061:		customPrintf(str, outputFile);
call    0 returned 100%
        -: 1062:	}
        -: 1063:
        3: 1064:	if (choice1 != 2)
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -: 1065:	{
        2: 1066:		if (G->coins != tempG.coins)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1067:		{
    #####: 1068:			passesCheck = overallTestPass = 0;
        -: 1069:		}
        -: 1070:	}
        -: 1071:	else
        -: 1072:	{
        1: 1073:		if (G->coins + 2 != tempG.coins)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1074:		{
    #####: 1075:			passesCheck = overallTestPass = 0;
        -: 1076:		}
        -: 1077:	}
        -: 1078:	
        -: 1079:
        -: 1080:	//output status to screen and file
        3: 1081:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1082:	{
        3: 1083:		if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1084:		{
        3: 1085:			sprintf(str, "Passed.\n");
        3: 1086:			customPrintf(str, outputFile);
call    0 returned 100%
        -: 1087:		}
        -: 1088:		else
        -: 1089:		{
    #####: 1090:			sprintf(str, "Failed!!!!!\n");
    #####: 1091:			customPrintf(str, outputFile);
call    0 never executed
        -: 1092:		}
        -: 1093:	}
        -: 1094:
        -: 1095:	//free dynamic memory
        3: 1096:	free(str);
        -: 1097:
        -: 1098:	//return final result
        3: 1099:	return overallTestPass;
        -: 1100:}
        -: 1101:
        -: 1102:/*
        -: 1103:	void testCardEffectSteward()
        -: 1104:	Parameters:
        -: 1105:		None
        -: 1106:	Returns:
        -: 1107:		Nothing
        -: 1108:	Description:
        -: 1109:		Will test the 'steward' cardEffect with varying inputs.
        -: 1110:*/
function testCardEffectSteward called 1 returned 100% blocks executed 83%
        1: 1111:void testCardEffectSteward()
        -: 1112:{
        -: 1113:	//create two gameState objects
        -: 1114:	struct gameState G, backupG;
        -: 1115:	
        -: 1116:	//set the initial player count to 4
        1: 1117:	int playerCount = 4;
        -: 1118:	
        -: 1119:	//setting the playerIndex to 0'th player
        1: 1120:	int playerIndex = 0;
        -: 1121:	
        -: 1122:	//variable to keep track of test number
        1: 1123:	int testnum = 1;
        -: 1124:	
        -: 1125:	//initial supply cards
        1: 1126:	int k[10] = { adventurer, embargo, village, minion, mine, cutpurse,
        -: 1127:		sea_hag, remodel, smithy, council_room };
        -: 1128:		
        -: 1129:	//bonus coins
        1: 1130:	int bonusCoins = 0;
        -: 1131:
        -: 1132:	//random seed
        1: 1133:	int randomSeed = 1;
        -: 1134:	
        -: 1135:	//initialize the gameState object
        1: 1136:	int res = initializeGame(playerCount, k, randomSeed, &G);
call    0 returned 100%
        -: 1137:	//this should always pass, if it doesn't we need to exit
        1: 1138:	assert(res == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1139:
        -: 1140:	//initialze a string of all '\0' chars
        1: 1141:	char *str = malloc(sizeof(char) * MAX_STRING_SIZE);
        1: 1142:	memset(str, '\0', sizeof(char) * MAX_STRING_SIZE);
        -: 1143:
        -: 1144:	//create a file pointer to output file
        1: 1145:	FILE *outputFile = fopen("cardtest1.out", "w");
call    0 returned 100%
        -: 1146:	
        -: 1147:	//output current test information
        1: 1148:	sprintf(str, "Test %d: Playing Card 'steward' opting to gain two cards.\n", testnum++);
        1: 1149:	customPrintf(str, outputFile);
call    0 returned 100%
        -: 1150:
        -: 1151:	//backup G for testing
        1: 1152:	memcpy(&backupG, &G, sizeof(struct gameState));
        -: 1153:
        -: 1154:	//now manipulate the cards in the player's hand to be known values
        1: 1155:	backupG.handCount[playerIndex] = 0;
        1: 1156:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = copper;
        1: 1157:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = silver;
        1: 1158:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = gold;
        1: 1159:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1: 1160:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = steward;
        -: 1161:	
        -: 1162:	//run the function and validate it
        1: 1163:	res = validateStewardCardEffect(playerIndex, 4, steward, 1, -1, -1, &bonusCoins, &backupG, 1, outputFile, 0);
call    0 returned 100%
        -: 1164:	
        -: 1165:	//check the result and output status
        1: 1166:	if (res == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1167:	{
    #####: 1168:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -: 1169:	}
        -: 1170:	else
        -: 1171:	{
        1: 1172:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -: 1173:	}
        1: 1174:	customPrintf(str, outputFile);
call    0 returned 100%
        -: 1175:
        -: 1176:	//output current test information
        1: 1177:	sprintf(str, "Test %d: Playing Card 'steward' opting to gain two coins.\n", testnum++);
        1: 1178:	customPrintf(str, outputFile);
call    0 returned 100%
        -: 1179:
        -: 1180:	//backup G for testing
        1: 1181:	memcpy(&backupG, &G, sizeof(struct gameState));
        -: 1182:
        -: 1183:	//now manipulate the cards in the player's hand to be known values
        1: 1184:	backupG.handCount[playerIndex] = 0;
        1: 1185:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = copper;
        1: 1186:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = silver;
        1: 1187:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = gold;
        1: 1188:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1: 1189:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = steward;
        -: 1190:	
        -: 1191:	//run the function and validate it
        1: 1192:	res = validateStewardCardEffect(playerIndex, 4, steward, 2, -1, -1, &bonusCoins, &backupG, 1, outputFile, 0);
call    0 returned 100%
        -: 1193:	
        -: 1194:	//check the results and output status
        1: 1195:	if (res == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1196:	{
    #####: 1197:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -: 1198:	}
        -: 1199:	else
        -: 1200:	{
        1: 1201:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -: 1202:	}
        1: 1203:	customPrintf(str, outputFile);
call    0 returned 100%
        -: 1204:
        -: 1205:	//output current test information
        1: 1206:	sprintf(str, "Test %d: Playing Card 'steward' opting to trash two cards.\n", testnum++);
        1: 1207:	customPrintf(str, outputFile);
call    0 returned 100%
        -: 1208:
        -: 1209:	//backup G for testing
        1: 1210:	memcpy(&backupG, &G, sizeof(struct gameState));
        -: 1211:
        -: 1212:	//now manipulate the cards in the player's hand to be known values
        1: 1213:	backupG.handCount[playerIndex] = 0;
        1: 1214:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = copper;
        1: 1215:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = silver;
        1: 1216:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = gold;
        1: 1217:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1: 1218:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = steward;
        -: 1219:	
        -: 1220:	//run the function and validate it
        1: 1221:	res = validateStewardCardEffect(playerIndex, 4, steward, 3, 0, 1, &bonusCoins, &backupG, 1, outputFile, 0);
call    0 returned 100%
        -: 1222:	
        -: 1223:	//check the results and output status
        1: 1224:	if (res == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1225:	{
    #####: 1226:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -: 1227:	}
        -: 1228:	else
        -: 1229:	{
        1: 1230:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -: 1231:	}
        1: 1232:	customPrintf(str, outputFile);
call    0 returned 100%
        -: 1233:
        -: 1234:	//close the output file
        1: 1235:	fclose(outputFile);
call    0 returned 100%
        -: 1236:	
        -: 1237:	//free dynamic memory
        1: 1238:	free(str);
        1: 1239:}
        -: 1240:
        -: 1241:/*
        -: 1242:	int main()
        -: 1243:	Parameters:
        -: 1244:		None
        -: 1245:	Returns:
        -: 1246:		int 0
        -: 1247:	Description:
        -: 1248:		Will test the 'steward' cardEffect with varying inputs.
        -: 1249:*/
function main called 1 returned 100% blocks executed 100%
        1: 1250:int main()
        -: 1251:{
        -: 1252:	//for handling segmentation fault errors
        -: 1253:	struct sigaction *sa;
        1: 1254:	sa = malloc(sizeof(struct sigaction));
        1: 1255:	sa->sa_handler = sig_segv_handler;
        1: 1256:	sigaction(SIGSEGV, sa, NULL);
call    0 returned 100%
        -: 1257:
        1: 1258:	testCardEffectSteward();
call    0 returned 100%
        1: 1259:	return 0;
        -: 1260:}
        -: 1261:
        -: 1262:
        -: 1263:
        -: 1264:
        -: 1265:
        -: 1266:
        -: 1267:
        -: 1268:
