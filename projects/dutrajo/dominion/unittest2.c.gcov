        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include "dominion.h"
        -:    2:#include "dominion_helpers.h"
        -:    3:#include "rngs.h"
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <assert.h>
        -:    7:#include <string.h>
        -:    8:#include <unistd.h>
        -:    9:
        -:   10://set array size for output strings
        -:   11:#define MAX_STRING_SIZE 10000
        -:   12:
        -:   13:
        -:   14:/*
        -:   15:	void initializeString(
        -:   16:					char* str,
        -:   17:					int size
        -:   18:					)
        -:   19:	Parameters:
        -:   20:		char* str: char* array to initialize
        -:   21:		int size: size of char* array
        -:   22:	Returns:
        -:   23:		Nothing
        -:   24:	Description:
        -:   25:		Will set all of the char array to '\0' characters
        -:   26:		to ensure a proper formatted string.
        -:   27:*/
function initializeString called 99 returned 100% blocks executed 100%
       99:   28:void initializeString(char *str, int size)
        -:   29:{
        -:   30:	//validate pointer isn't null
       99:   31:	if (str != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   32:	{
        -:   33:		//initialize array to all '\0' characters
       99:   34:		memset(str, '\0', sizeof(char) * size);
        -:   35:	}
       99:   36:}
        -:   37:
        -:   38:/*
        -:   39:	void customPrintf(
        -:   40:			char* line,
        -:   41:			FILE* outputFile
        -:   42:			)
        -:   43:	Parameters:
        -:   44:		char* line: string to output,
        -:   45:		FILE* outputFile: file pointer to output file (can be null)
        -:   46:	Returns:
        -:   47:		Nothing
        -:   48:	Description:
        -:   49:		Will output a string (ends with '\0') to the console as well
        -:   50:		as to the output file if the pointer isn't null.
        -:   51:*/
function customPrintf called 90 returned 100% blocks executed 100%
       90:   52:void customPrintf(char* line, FILE* outputFile)
        -:   53:{
        -:   54:	//output the line to the console
       90:   55:	printf("%s", line);
call    0 returned 100%
        -:   56:
        -:   57:	//check if the file pointer is null
       90:   58:	if (outputFile != NULL)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   59:	{
        -:   60:		//not null, so output to file
       90:   61:		fprintf(outputFile, "%s", line);
call    0 returned 100%
        -:   62:	}
        -:   63:
        -:   64:	//re-initialize string 
       90:   65:	initializeString(line, MAX_STRING_SIZE);
call    0 returned 100%
       90:   66:}
        -:   67:
        -:   68:/*
        -:   69:	int validateUpdateCoinsFunction(
        -:   70:		int playerIndex,
        -:   71:		int coins,
        -:   72:		struct gameState *G,
        -:   73:		int detailedOutput,
        -:   74:		FILE* outputFile,
        -:   75:		int expectedPassOrFail,
        -:   76:		int exitAfterFunctionFail
        -:   77:		)
        -:   78:	Parameters:
        -:   79:		int playerIndex: index of player whose turn it is
        -:   80:		int coins: coins to add or remove (bonus coins)
        -:   81:		struct gameState *G: gameState to use
        -:   82:		int detailedOutput: indicate if detailed output is needed
        -:   83:		FILE* outputFile: file to output results to (can be null)
        -:   84:		int expectedPassOrFail: what we expect the initial function call to return
        -:   85:		int exitAfterFunctionFail: if we should stop test if we don't get expected output
        -:   86:	Returns:
        -:   87:		int, 0 if fail, 1 if succes
        -:   88:	Description:
        -:   89:		This function can be used to perform a single test on a valid gameState object
        -:   90:		using the updateCoins function. It checks that the updateCoins function
        -:   91:		properly calculates the treasure in the player's hand and add's or subtracts
        -:   92:		the bonus value. It performs validation checks on the original function to findfirst
        -:   93:		any bugs.
        -:   94:*/
function validateUpdateCoinsFunction called 9 returned 100% blocks executed 77%
        9:   95:int validateUpdateCoinsFunction(
        -:   96:	int playerIndex,
        -:   97:	int coins,
        -:   98:	struct gameState *G,
        -:   99:	int detailedOutput,//0 = no output, 1 = output
        -:  100:	FILE* outputFile,
        -:  101:	int expectedPassOrFail, //0 = expect fail, 1 = expect pass
        -:  102:	int exitAfterFunctionFail //1 = exit test if function != expected
        -:  103:)
        -:  104:{
        -:  105:	//make backup for testing
        -:  106:	struct gameState tempG;
        -:  107:
        -:  108:	//create dynamic memory for output string
        9:  109:	char *str = malloc(sizeof(char) * MAX_STRING_SIZE);
        -:  110:
        -:  111:	//initialize the string
        9:  112:	initializeString(str, MAX_STRING_SIZE);
call    0 returned 100%
        -:  113:
        -:  114:	//first copy gameState to test object
        9:  115:	memcpy(&tempG, G, sizeof(struct gameState));
        -:  116:
        -:  117:	//indicator for individual test pass
        9:  118:	int passesCheck = 1;
        -:  119:
        -:  120:	//indiciator for all test pass
        9:  121:	int overallTestPass = 1;
        -:  122:
        -:  123:	//counter variable
        9:  124:	int i = 0;
        9:  125:	int j = 0;
        -:  126:
        -:  127:	//results stuff
        9:  128:	int expected = 0;
        9:  129:	int found = 0;
        -:  130:
        -:  131:	//bonus coins to add
        9:  132:	int bonusCoins = coins;
        -:  133:
        -:  134:	//set check
        9:  135:	passesCheck = 1;
        -:  136:
        -:  137:	//execute the card effect
        9:  138:	sprintf(str, "\tRunning function updateCoins()....");
        9:  139:	if (detailedOutput) customPrintf(str, outputFile);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
call    2 returned 100%
        -:  140:
        9:  141:	int res = updateCoins(playerIndex, &tempG, bonusCoins);
call    0 returned 100%
        9:  142:	assert(res == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  143:
        9:  144:	found = tempG.coins;
        9:  145:	expected = expectedPassOrFail;
        -:  146:
        9:  147:	if (found != expected)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  148:	{
    #####:  149:		passesCheck = overallTestPass = 0;
        -:  150:	}
        -:  151:
        -:  152:	//output status to screen and file
        9:  153:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  154:	{
        9:  155:		if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  156:		{
        9:  157:			sprintf(str, "Expected: %d, Found: %d. Passed.\n", expected, found);
        9:  158:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  159:		}
        -:  160:		else
        -:  161:		{
    #####:  162:			sprintf(str, "Expected: %d, Found: %d. Failed!!!!!\n", expected, found);
    #####:  163:			customPrintf(str, outputFile);
call    0 never executed
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	//checking function result
        9:  168:	if (found != expected && exitAfterFunctionFail == 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
        -:  169:	{
    #####:  170:		overallTestPass = 0;
    #####:  171:		return overallTestPass; //break out of function early
        -:  172:	}
        -:  173:
        -:  174:	//reset check
        9:  175:	passesCheck = 1;
        -:  176:
        -:  177:	//output status to screen and file
        9:  178:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  179:	{
        9:  180:		sprintf(str, "\tChecking coins calculated correctly...");
        9:  181:		customPrintf(str, outputFile);
call    0 returned 100%
        -:  182:	}
        -:  183:
        -:  184:	//calculating coins in player's hand manually
        9:  185:	int totalCoinsExpected = bonusCoins;
     1534:  186:	for (i = 0; i < tempG.handCount[playerIndex]; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  187:	{
     1525:  188:		if (tempG.hand[playerIndex][i] == copper)
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -:  189:		{
      503:  190:			totalCoinsExpected += 1;
        -:  191:		}
     1022:  192:		else if (tempG.hand[playerIndex][i] == silver)
branch  0 taken 49% (fallthrough)
branch  1 taken 51%
        -:  193:		{
      502:  194:			totalCoinsExpected += 2;
        -:  195:		}
      520:  196:		else if (tempG.hand[playerIndex][i] == gold)
branch  0 taken 96% (fallthrough)
branch  1 taken 4%
        -:  197:		{
      501:  198:			totalCoinsExpected += 3;
        -:  199:		}
        -:  200:	}
        -:  201:
        -:  202:	//checking if they match
        9:  203:	if (totalCoinsExpected != tempG.coins)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  204:	{
    #####:  205:		passesCheck = overallTestPass = 0;
        -:  206:	}
        -:  207:
        -:  208:	//output status to screen and file
        9:  209:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  210:	{
        9:  211:		if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  212:		{
        9:  213:			sprintf(str, "Expected: %d, Found: %d. Passed.\n", totalCoinsExpected, tempG.coins);
        9:  214:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  215:		}
        -:  216:		else
        -:  217:		{
    #####:  218:			sprintf(str, "Expected: %d, Found: %d. Failed!!!!!\n", totalCoinsExpected, tempG.coins);
    #####:  219:			customPrintf(str, outputFile);
call    0 never executed
        -:  220:		}
        -:  221:	}
        -:  222:
        -:  223:
        -:  224:	//reset check
        9:  225:	passesCheck = 1;
        -:  226:
        -:  227:	//output status to screen and file
        9:  228:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  229:	{
        9:  230:		sprintf(str, "\tChecking ALL player's hands, decks, and discards weren't changed...");
        9:  231:		customPrintf(str, outputFile);
call    0 returned 100%
        -:  232:	}
        -:  233:
        -:  234:	//verify all player's hands, decks, discard piles are identical to original values before function execution
       45:  235:	for (i = 0; i < tempG.numPlayers; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -:  236:	{
        -:  237:		//jump out of loop if something fails
       36:  238:		if (!passesCheck) break;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  239:
        -:  240:		//make sure hand counts are the same
       36:  241:		if (tempG.handCount[i] == G->handCount[i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  242:		{
        -:  243:			//check player's hand for changes
     1561:  244:			for (j = 0; j < tempG.handCount[i]; j++)
branch  0 taken 98%
branch  1 taken 2% (fallthrough)
        -:  245:			{
        -:  246:				//if the hand cards aren't the same
     1525:  247:				if (tempG.hand[i][j] != G->hand[i][j])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  248:				{
        -:  249:					//fails check...
    #####:  250:					passesCheck = overallTestPass = 0;
    #####:  251:					break;
        -:  252:				}
        -:  253:			}
        -:  254:		}
        -:  255:		else
        -:  256:		{
        -:  257:			//original hand and new hand aren't the same count
    #####:  258:			passesCheck = overallTestPass = 0;
    #####:  259:			break;
        -:  260:		}
        -:  261:
        -:  262:		//make sure deck counts are the same
       36:  263:		if (tempG.deckCount[i] == G->deckCount[i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  264:		{
        -:  265:			//iterate through cards and make sure identical
      387:  266:			for (j = 0; j < tempG.deckCount[i]; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:  267:			{
        -:  268:				//check if cards are the same
      351:  269:				if (tempG.deck[i][j] != G->deck[i][j])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  270:				{
        -:  271:					//fails check...
    #####:  272:					passesCheck = overallTestPass = 0;
    #####:  273:					break;
        -:  274:				}
        -:  275:			}
        -:  276:		}
        -:  277:		else
        -:  278:		{
        -:  279:			//original deck count doesn't match new deck count
    #####:  280:			passesCheck = 0;
    #####:  281:			break;
        -:  282:		}
        -:  283:
        -:  284:		//check discard piles are the same
       36:  285:		if (tempG.discardCount[i] == G->discardCount[i])
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  286:		{
        -:  287:			//iterate through discard piles and check for identical
       36:  288:			if (tempG.discard[i][j] != G->discard[i][j])
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  289:			{
        -:  290:				//fails check....
    #####:  291:				passesCheck = overallTestPass = 0;
    #####:  292:				break;
        -:  293:			}
        -:  294:		}
        -:  295:		else
        -:  296:		{
        -:  297:			//original discard pile doesn't match new one
    #####:  298:			passesCheck = overallTestPass = 0;
    #####:  299:			break;
        -:  300:		}
        -:  301:		
        -:  302:	}
        -:  303:
        -:  304:	//output status to screen and file
        9:  305:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  306:	{
        9:  307:		if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  308:		{
        9:  309:			sprintf(str, "Passed.\n");
        9:  310:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  311:		}
        -:  312:		else
        -:  313:		{
    #####:  314:			sprintf(str, "Failed!!!!!\n");
    #####:  315:			customPrintf(str, outputFile);
call    0 never executed
        -:  316:		}
        -:  317:	}
        -:  318:
        -:  319:	//reset check
        9:  320:	passesCheck = 1;
        -:  321:
        -:  322:	//output status to screen and file
        9:  323:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  324:	{
        9:  325:		sprintf(str, "\tChecking current player's turn hasn't changed...");
        9:  326:		customPrintf(str, outputFile);
call    0 returned 100%
        -:  327:	}
        -:  328:
        -:  329:	//also check that player's turn hasn't changed 
        9:  330:	if (tempG.whoseTurn != G->whoseTurn)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  331:	{
        -:  332:		//function modified turn inside card effect (shouldn't happen)
    #####:  333:		passesCheck = overallTestPass = 0;
        -:  334:	}
        -:  335:
        -:  336:	//output status to screen and file
        9:  337:	if (detailedOutput)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  338:	{
        9:  339:		if (passesCheck == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  340:		{
        9:  341:			sprintf(str, "Passed.\n");
        9:  342:			customPrintf(str, outputFile);
call    0 returned 100%
        -:  343:		}
        -:  344:		else
        -:  345:		{
    #####:  346:			sprintf(str, "Failed!!!!!\n");
    #####:  347:			customPrintf(str, outputFile);
call    0 never executed
        -:  348:		}
        -:  349:	}
        -:  350:
        9:  351:	free(str);
        -:  352:
        9:  353:	return overallTestPass;
        -:  354:}
        -:  355:
        -:  356:/*
        -:  357:	void testUpdateCoinsFunction()
        -:  358:	Parameters:
        -:  359:		None.
        -:  360:	Returns:
        -:  361:		None.
        -:  362:	Description:
        -:  363:		This function will perform several tests of the updateCoins function
        -:  364:		by calling the test harness function above. Test results will be
        -:  365:		both output to screen and to a text file.
        -:  366:*/
function testUpdateCoinsFunction called 1 returned 100% blocks executed 86%
        1:  367:void testUpdateCoinsFunction()
        -:  368:{
        -:  369:	//create two gameState objects
        -:  370:	struct gameState G, backupG;
        -:  371:
        -:  372:	//set the initial player count to 4
        1:  373:	int playerCount = 4;
        -:  374:
        -:  375:	//setting the playerIndex to 0'th player
        1:  376:	int playerIndex = 0;
        -:  377:
        -:  378:	//variable to keep track of test number
        1:  379:	int testnum = 1;
        -:  380:
        -:  381:	//initial supply cards
        1:  382:	int k[10] = { adventurer, embargo, village, minion, mine, cutpurse,
        -:  383:		sea_hag, remodel, smithy, council_room };
        -:  384:
        -:  385:	//bonus coins
        1:  386:	int bonusCoins = 0;
        -:  387:
        -:  388:	//random seed
        1:  389:	int randomSeed = 1;
        -:  390:
        -:  391:	//loop counter
        1:  392:	int i = 0;
        -:  393:
        -:  394:	//initialize the gameState object
        1:  395:	int res = initializeGame(playerCount, k, randomSeed, &G);
call    0 returned 100%
        -:  396:	//this should always pass, if it doesn't we need to exit
        1:  397:	assert(res == 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -:  398:
        -:  399:	//initialze a string of all '\0' chars
        1:  400:	char *str = malloc(sizeof(char) * MAX_STRING_SIZE);
        1:  401:	memset(str, '\0', sizeof(char) * MAX_STRING_SIZE);
        -:  402:
        -:  403:	//create a file pointer to output file
        1:  404:	FILE *outputFile = fopen("unittest2.out", "w");
call    0 returned 100%
        -:  405:
        -:  406:	//output current test information
        1:  407:	sprintf(str, "Test %d: testing updateCoins function with zero coins in hand, and no bonus.\n", testnum++);
        1:  408:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  409:
        -:  410:	//backup G for testing with backup
        1:  411:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  412:
        -:  413:	//now manipulate the cards in the player's hand to be known values
        1:  414:	backupG.handCount[playerIndex] = 0;
        1:  415:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  416:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  417:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  418:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  419:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        -:  420:
        -:  421:	//also manipulate player's deck to be known values
        -:  422:	//so that we enter all parts of the test function
        1:  423:	backupG.deckCount[playerIndex] = 0;
        1:  424:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  425:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  426:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  427:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  428:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  429:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  430:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  431:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  432:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  433:
        1:  434:	bonusCoins = 0;
        -:  435:
        1:  436:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, 0, 1);
call    0 returned 100%
        -:  437:
        -:  438:	//check the result and output status
        1:  439:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  440:	{
        1:  441:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  442:	}
        -:  443:	else
        -:  444:	{
    #####:  445:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  446:	}
        1:  447:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  448:
        -:  449:	//output current test information
        1:  450:	sprintf(str, "Test %d: testing updateCoins function with zero coins in hand, and 1 bonus.\n", testnum++);
        1:  451:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  452:
        -:  453:	//backup G for testing with backup
        1:  454:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  455:
        -:  456:	//now manipulate the cards in the player's hand to be known values
        1:  457:	backupG.handCount[playerIndex] = 0;
        1:  458:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  459:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  460:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  461:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  462:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        -:  463:
        -:  464:	//also manipulate player's deck to be known values
        -:  465:	//so that we enter all parts of the test function
        1:  466:	backupG.deckCount[playerIndex] = 0;
        1:  467:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  468:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  469:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  470:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  471:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  472:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  473:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  474:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  475:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  476:
        1:  477:	bonusCoins = 1;
        -:  478:
        1:  479:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, 1, 1);
call    0 returned 100%
        -:  480:
        -:  481:	//check the result and output status
        1:  482:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  483:	{
        1:  484:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  485:	}
        -:  486:	else
        -:  487:	{
    #####:  488:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  489:	}
        1:  490:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  491:
        -:  492:	//output current test information
        1:  493:	sprintf(str, "Test %d: testing updateCoins function with 1 copper + 1 silver in hand, and 1 bonus.\n", testnum++);
        1:  494:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  495:
        -:  496:	//backup G for testing with backup
        1:  497:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  498:
        -:  499:	//now manipulate the cards in the player's hand to be known values
        1:  500:	backupG.handCount[playerIndex] = 0;
        1:  501:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = copper;
        1:  502:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = silver;
        1:  503:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  504:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  505:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        -:  506:
        -:  507:	//also manipulate player's deck to be known values
        -:  508:	//so that we enter all parts of the test function
        1:  509:	backupG.deckCount[playerIndex] = 0;
        1:  510:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  511:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  512:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  513:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  514:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  515:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  516:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  517:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  518:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  519:
        1:  520:	bonusCoins = 1;
        -:  521:
        1:  522:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, 4, 1);
call    0 returned 100%
        -:  523:
        -:  524:	//check the result and output status
        1:  525:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  526:	{
        1:  527:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  528:	}
        -:  529:	else
        -:  530:	{
    #####:  531:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  532:	}
        1:  533:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  534:
        -:  535:	//output current test information
        1:  536:	sprintf(str, "Test %d: testing updateCoins function with 1 copper + 1 silver + 1 gold in hand, and 1 bonus.\n", testnum++);
        1:  537:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  538:
        -:  539:	//backup G for testing with backup
        1:  540:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  541:
        -:  542:	//now manipulate the cards in the player's hand to be known values
        1:  543:	backupG.handCount[playerIndex] = 0;
        1:  544:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = copper;
        1:  545:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = silver;
        1:  546:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = gold;
        1:  547:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  548:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        -:  549:
        -:  550:	//also manipulate player's deck to be known values
        -:  551:	//so that we enter all parts of the test function
        1:  552:	backupG.deckCount[playerIndex] = 0;
        1:  553:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  554:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  555:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  556:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  557:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  558:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  559:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  560:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  561:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  562:
        1:  563:	bonusCoins = 1;
        -:  564:
        1:  565:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, 7, 1);
call    0 returned 100%
        -:  566:
        -:  567:	//check the result and output status
        1:  568:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  569:	{
        1:  570:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  571:	}
        -:  572:	else
        -:  573:	{
    #####:  574:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  575:	}
        1:  576:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  577:
        -:  578:	//output current test information
        1:  579:	sprintf(str, "Test %d: testing updateCoins function with %d copper in player's hand, and 0 bonus.\n", testnum++, MAX_HAND);
        1:  580:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  581:
        -:  582:	//backup G for testing with backup
        1:  583:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  584:
        -:  585:	//now manipulate the cards in the player's hand to be known values
        1:  586:	backupG.handCount[playerIndex] = 0;
      501:  587:	for (i = 0; i < MAX_HAND; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  588:	{
      500:  589:		backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = copper;
        -:  590:	}
        -:  591:	
        -:  592:
        -:  593:	//also manipulate player's deck to be known values
        -:  594:	//so that we enter all parts of the test function
        1:  595:	backupG.deckCount[playerIndex] = 0;
        1:  596:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  597:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  598:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  599:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  600:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  601:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  602:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  603:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  604:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  605:
        1:  606:	bonusCoins = 0;
        -:  607:
        1:  608:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, MAX_HAND, 1);
call    0 returned 100%
        -:  609:
        -:  610:	//check the result and output status
        1:  611:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  612:	{
        1:  613:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  614:	}
        -:  615:	else
        -:  616:	{
    #####:  617:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  618:	}
        1:  619:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  620:
        -:  621:	//output current test information
        1:  622:	sprintf(str, "Test %d: testing updateCoins function with %d silver in player's hand, and 0 bonus.\n", testnum++, MAX_HAND);
        1:  623:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  624:
        -:  625:	//backup G for testing with backup
        1:  626:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  627:
        -:  628:	//now manipulate the cards in the player's hand to be known values
        1:  629:	backupG.handCount[playerIndex] = 0;
      501:  630:	for (i = 0; i < MAX_HAND; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  631:	{
      500:  632:		backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = silver;
        -:  633:	}
        -:  634:
        -:  635:
        -:  636:	//also manipulate player's deck to be known values
        -:  637:	//so that we enter all parts of the test function
        1:  638:	backupG.deckCount[playerIndex] = 0;
        1:  639:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  640:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  641:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  642:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  643:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  644:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  645:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  646:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  647:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  648:
        1:  649:	bonusCoins = 0;
        -:  650:
        1:  651:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, MAX_HAND * 2, 1);
call    0 returned 100%
        -:  652:
        -:  653:	//check the result and output status
        1:  654:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  655:	{
        1:  656:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  657:	}
        -:  658:	else
        -:  659:	{
    #####:  660:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  661:	}
        1:  662:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  663:
        -:  664:	//output current test information
        1:  665:	sprintf(str, "Test %d: testing updateCoins function with %d gold in player's hand, and 0 bonus.\n", testnum++, MAX_HAND);
        1:  666:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  667:
        -:  668:	//backup G for testing with backup
        1:  669:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  670:
        -:  671:	//now manipulate the cards in the player's hand to be known values
        1:  672:	backupG.handCount[playerIndex] = 0;
      501:  673:	for (i = 0; i < MAX_HAND; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  674:	{
      500:  675:		backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = gold;
        -:  676:	}
        -:  677:
        -:  678:
        -:  679:	//also manipulate player's deck to be known values
        -:  680:	//so that we enter all parts of the test function
        1:  681:	backupG.deckCount[playerIndex] = 0;
        1:  682:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  683:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  684:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  685:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  686:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  687:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  688:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  689:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  690:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  691:
        1:  692:	bonusCoins = 0;
        -:  693:
        1:  694:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, MAX_HAND * 3, 1);
call    0 returned 100%
        -:  695:
        -:  696:	//check the result and output status
        1:  697:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  698:	{
        1:  699:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  700:	}
        -:  701:	else
        -:  702:	{
    #####:  703:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  704:	}
        1:  705:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  706:
        -:  707:	//output current test information
        1:  708:	sprintf(str, "Test %d: testing updateCoins function with 1 copper in player's hand, and -1 bonus.\n", testnum++);
        1:  709:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  710:
        -:  711:	//backup G for testing with backup
        1:  712:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  713:
        -:  714:	//now manipulate the cards in the player's hand to be known values
        1:  715:	backupG.handCount[playerIndex] = 0;
        1:  716:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = copper;
        1:  717:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  718:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  719:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        1:  720:	backupG.hand[playerIndex][backupG.handCount[playerIndex]++] = estate;
        -:  721:
        -:  722:
        -:  723:	//also manipulate player's deck to be known values
        -:  724:	//so that we enter all parts of the test function
        1:  725:	backupG.deckCount[playerIndex] = 0;
        1:  726:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  727:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  728:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  729:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  730:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  731:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  732:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  733:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  734:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  735:
        1:  736:	bonusCoins = -1;
        -:  737:
        1:  738:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, 0, 1);
call    0 returned 100%
        -:  739:
        -:  740:	//check the result and output status
        1:  741:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  742:	{
        1:  743:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  744:	}
        -:  745:	else
        -:  746:	{
    #####:  747:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  748:	}
        1:  749:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  750:
        -:  751:	//output current test information
        1:  752:	sprintf(str, "Test %d: testing updateCoins function with 0 card's in player's hand.\n", testnum++);
        1:  753:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  754:
        -:  755:	//backup G for testing with backup
        1:  756:	memcpy(&backupG, &G, sizeof(struct gameState));
        -:  757:
        -:  758:	//now manipulate the cards in the player's hand to be known values
        1:  759:	backupG.handCount[playerIndex] = 0;
        -:  760:
        -:  761:
        -:  762:
        -:  763:	//also manipulate player's deck to be known values
        -:  764:	//so that we enter all parts of the test function
        1:  765:	backupG.deckCount[playerIndex] = 0;
        1:  766:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  767:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  768:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  769:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  770:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = copper;
        1:  771:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  772:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  773:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        1:  774:	backupG.deck[playerIndex][backupG.deckCount[playerIndex]++] = estate;
        -:  775:
        1:  776:	bonusCoins = 0;
        -:  777:
        1:  778:	res = validateUpdateCoinsFunction(playerIndex, bonusCoins, &backupG, 1, outputFile, 0, 1);
call    0 returned 100%
        -:  779:
        -:  780:	//check the result and output status
        1:  781:	if (res == 1)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  782:	{
        1:  783:		sprintf(str, "------------- OVERALL TEST PASSED ---------------\n\n");
        -:  784:	}
        -:  785:	else
        -:  786:	{
    #####:  787:		sprintf(str, "------------- OVERALL TEST FAILED!!!! ---------------\n\n");
        -:  788:	}
        1:  789:	customPrintf(str, outputFile);
call    0 returned 100%
        -:  790:
        -:  791:	//close the output file
        1:  792:	fclose(outputFile);
call    0 returned 100%
        -:  793:
        -:  794:	//free dynamic memory
        1:  795:	free(str);
        1:  796:}
        -:  797:
        -:  798:/*
        -:  799:	int main()
        -:  800:	Parameters:
        -:  801:		None.
        -:  802:	Returns:
        -:  803:		int 0
        -:  804:	Description:
        -:  805:		main launching point for the program.
        -:  806:*/
function main called 1 returned 100% blocks executed 100%
        1:  807:int main()
        -:  808:{
        1:  809:	testUpdateCoinsFunction();
call    0 returned 100%
        1:  810:	return 0;
        -:  811:}
